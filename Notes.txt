Udit Sharma

Stack:
													
1.Push at bottom
    -> when empty return and push element at the same time
    -> top = s.pop()
    -> call function for the stack left after popping one element
    -> push(top) in backtracking

2. Reverse Stack
    -> return if stack is empty
    -> top = s.pop()
    -> call the reverse(s) function for remainig stack
    -> push at bottom(s, top) backtracking step

3. Duplicate Parenthesis
    -> first check if the string is valid or not 
    -> it is valid if the number of opening and closing brackets is same
    -> create a boolean function that take the string as input 
    -> create a charater stack
    -> traverse the string using a for loop
    -> if we find a closing bracket i.e. ')' then:
	1. create a cnt variable (cnt = 0)
	2. pop elements from the stack until we find the opening bracket i.e. '('.
	3. do it using a while loop and increase the cnt in the same loop
 	4. after while loop return true if cnt = 0
    -> else push the character into the stack
    -> lastly after the for loop return false

4. Next Greater Element
    -> create a function that take the element array as input and return the NGE array
    -> create a stack of integer type and a nge array of size of given array
    -> using a for loop traverse the given array
    -> while stack is not empty and the arr[i] > arr[s.peek()]
    -> nge[s.peek()] = i and pop() element from the stack
    -> after the while loop push the index 'i' into the stack
    -> after the for loop using a while loop associate the nge of left elements as -1

5. Max Rectangle Area
    -> create a function that takes the area of heights as input
    -> create a variable area to store the final area and initialize it as -1
    -> create two arrays left and right of same size as of heights array
    -> create a stack of integer type
    -> in the right array store the index of next smaller element of the current index to its right
    -> same code as NGE as for the remaining assign the index of the last element
    -> in the left array store the index of next smaller element of the current index to its left
    -> start travesing from the end and for the remaining assign index of the first element
    -> h = height[i]
    -> w = right[i]  - left[i] - 1
    -> area = Math.max(area, (h*w))
    -> lastly return the area



Queue:

1. 1st Non-repeating letter ***
    -> a freqency arr[26] and a Character queue
    -> loop the string => c = s.charAt(i)
    -> increase the freqence of character freq[c-'a']++
    -> add the character (c) to the queue
    -> remove "c" from queue while queue is not empty and freq[q.peek()-'a'] > 1
    -> if q.isEmpty() sot("-1") else sot(q.peek())

2. Interleave two halfs of Queue
    *even length case only possible
    -> add last half element of queue in another queue
    -> create a final queue using the two queues
    -> add 1st element from Q1 and 2nd element from Q2

3. Reverse Queue
    -> create a function that takes the given queue 'q' as input
    -> if q becomes empty return
    -> data = q.peek()
    -> q.remove()
    -> call the function for 'q'
    -> backtracking step add data to 'q'



Linked List:

1. Reverse Linked List
    -> Three pointers prev, curr and nxt
    -> prev = null, curr = head and nxt = null
    -> point the tail at the head   
    -> while ( curr != null): 
	inside the while loop initialize the nxt pointer to curr.next,
        we would reverse the links between the nodes by pointing the 
 	curr.next to the 'prev' pointer and the next of the 'nxt' pointer 
	to the 'curr' pointer, after this we would update the 'prev' pointer
	to point at 'curr' pointer and the 'curr' pointer will point at 'nxt'.
    -> lastly we would update our original head == prev.

2. Detect and Remove Cycle (Floyd's Algo)
* we use fast and slow pointer appoach to find the cycle in the linked list.
    -> fast += 2 and slow += 1
    -> if they meet at any point which means a cycle exists in the linked list
    -> when they meet stop the loop
    -> check if slow is equal to the head or not
    -> if not then initialise slow as head
    -> run the while loop until slow.next != fast.next
    -> else if slow point to the head
    -> increase fast using a while loop until fast.next != slow
    -> lastly point fast to null

3. Check Palindrome **
*we can simply push the elements of our linked list in an arrayList and
check if the arrayList is a palindrome but we would be using the slow 
fast pointer approach to find the center of linked list and the concept 
of reversing half linked list.
    -> find the middle of the list
    -> reverse the second half of the list
    -> compare the 1st and the reversed 2nd half of the list

4. Mergesort
    -> if head || head.next is null return the head
    -> first find the mid of the linked list
    -> return type of the function will be node
    -> right head will be the next of mid
    -> point the next of mid to null this would create to linked list
    -> for left part call for head and for right call for mid.next
    -> lastly call the merge function
    -> create a new linked list with a single node(-1) and temp pointing at its head
    -> merge function will be similar to the one used in arrays

5. Reverse DLL
* just add a line curr.prev = next in the code we used to reverse a SLL.



Recursion & Backtracking:

1. Subset
    -> Yes condition (ans + character)
    -> No condition (ans, pass empty string)

2. Permutation
    -> for loop (recursion inside it)
    -> newString = substr(0, i) + substr(i+1)
    -> func( newString, ans + c)
    -> c = character remove from original string

3. Qiuck Sort **
    -> s >= e return
    -> pivot = choose the last element
    -> i = starting index - 1
    -> arr[j] < pivot = perform swap
    -> call for left and right part of pivot

4. Merge Sort **
    -> s >= e return
    -> call for s to mid and mid+1 to e
    -> perform merge on left and right part
    -> left = 0 to mid-s+1 (size)  arr[i+s]
    -> right = 0 to e-mid (size)   arr[i+mid+1]

5. nQueens ***
    -> have a char[][] 2d array i.e. board[][] = new char[n][n] of size n X n
    -> a row variable to track the no. of rows
    -> when the row becomes 'n' print the board and return
    -> for every board[row][col] put it equal to 'Q'
    -> call the recursive function and increase the row by one
    -> remove the 'Q' from board[row][col] == 'x' in the backtracking step
    -> create and isSafe function to check if the position of the queen is safe or not:
	1. check straight upwards (col remains constant)
	2. check diagnol left
	3. check diagnol right (tricky one)



BT (Binary Tree):

1. Level Order Traversal
    -> create a Queue <Node> q = new LinkedList<>();
    -> run a while loop until q is empty
    -> Node curr = q.remove()
    -> if curr is null there are two cases:
 	1. if 'q' gets empty break
	2. else print next line and add 'null' to queue
    -> if curr is not null then:
	1. print the data
	2. add curr.left to the queue if it exists
	3. add curr.right to the queue if it exists

2. kth ancestor of a node 
    -> create a function 'kth' that takes root node, n and k as the input
    -> if root becomes null return -1
    -> if we found 'n' i.e root.data == n then return 0
    -> call for root.left and store in int left
    -> call for root.right and store in int right
    -> if both are -1 return -1 to the main function
    -> else create a max variable and store max of both (left, right) + 1 in it
    -> if max == k print root.data
    -> lastly return max

3. Lowest Common Ancestor
    -> create a function 'lca' that takes root node an int 'a' and 'b' as the input
    -> if root becomes null return null
    -> if root.data become equal to either a or b return root
    -> call for root.left and store in Node left
    -> call for root.right and store in Node right
    -> if both left and right are not null return root
    -> lastly if left becomes null return right and vice versa
    (return left == null ? right : left)

4. Min distance b/w 2 nodes
    -> create a distance function that takes root node, a and b as inputs
    -> find the LCA of a & b and store it in Node lca
    -> find distance b/w lca and 'a' using distUtil function and store in int d1
    -> find distance b/w lca and 'b' using distUtil function and store in int d2
    -> return d1 + d2 from distance function
    -> distUtil function takes the lca and n as the input
    -> if root becomes null return -1
    -> if root.data becomes equal to n return 0
    -> call for root.left and store in int left
    -> call for root.right and store in int right
    -> if both become -1 return -1
    -> if one of the two becomes -1 return the other variable+1
    (return left == -1 ? right+1 : left+1)

5. Transform to Sum Tree
    -> if root == null return 0;
    -> call for the left and store in int left
    -> call for the right and store in int right
    -> create a variable data and assign it with root.data
    -> root.left == null ? 0 : root.left.data, store the value in newLeft
    -> root.right == null ? 0 : root.right.data, store the value in newRight
    -> now change value of root.data with (left + right + newLeft + newRight)
    -> lastly return data (it contains the value of the root node) 

6. Diameter of a Tree
    -> create a Info class that stores the height and diameter
    -> create a Info type function that takes root node as input
    -> if root == null return new Info( 0(height), 0(diameter) )
    -> call the function for left and store in Info left
    -> call the function for right and store in Info right
    -> now sd(self diameter) = left.height + right.height + 1 
    -> height = maximum of left height and right height + 1
    -> diameter = maximum of sd, left and right diameter
    -> lastly return new Info(height, diameter) 

7. Top View
    -> create a Info class that has an int hd (horizontal distance) and Node node
    -> using Info class create a Queue
    -> create a HashMap <Integer, Node>  m
    -> create two variables min and max to store the min and max node (initially zero)
    -> add new Info(0, root) to the queue as the distance of root node is zero
    -> traverse the queue using while loop 
    -> Info curr = q.remove()
    -> check if the curr.hd exists in the map or not
    -> if does not exist then put the curr.node and curr.hd in the map
    -> if curr.left.node is not null add new Info(curr.hd-1, curr.node.left) to the queue
    -> in the same if statement update min = Math.min(min, curr.hd-1)
    -> if curr.right.node is not null add new Info(curr.hd-1, curr.node.right) to the queue
    -> in the same if statement update max = Math.max(max, curr.hd+1)
    -> after while loop run a for loop from min to max and output map.get(i).data

8. Sub tree of another tree ***
    (covers 2-3 questions)
    -> create a function check that take to inputs Node root and Node subroot
    -> if root == null return false
    -> if root.data == subroot.data call isIdentical function
    -> if isIdentical gives true return true to the main function
    -> lastly return check(root.left, subroot) || check(root.right, subroot)
    -> in isIdentical function first check if root == null && subroot == null, return true
    -> else if root == null || subroot == null || root.data != subroot.data then return false
    -> now if isIdentical(root.left, subroot) gives false return false to the main function
    -> and if isIdentical(root.right, subroot) gives false return false to the main function
    -> lastly return true in isIdentical function



BST (Binary Search Tree):

1. Build BST 
    -> pass root and the data to the function
    -> if root is null make root the new Node containing data and return it
    -> if data is smaller than root.data then insert in the left subtree
    -> if data is greater than root.data then insert in the right subtree
    -> lastly return root
    -> print inorder sequence to check if the tree build is correct or not

2. Delete node‎
    -> create a function that takes the root node an the value (to be deleted) as inputs
    -> if data is greater than the root node call the funtion for the right subtree
    -> else if data is smaller than the root node call the fucntion for the left subtree
    -> else, this is the case we found the node to be deleted
    -> inside the else statement delete the node 
    -> 1st case check is root.right and root.left both are null, if yes return null
    -> 2nd case check if root.right is null, if so return root.left
    -> root.left is null return root.right
    -> 3rd case find the inorder successor and then delete the node
    -> inorder successor is the left most node in the right subtree of a node
    -> update root.data with inorder successor.data
    -> root.right = delete(root.right, inorder successor.data)
    -> in the end return root

3. Root - Leaf paths
    -> create a function that takes the root node and an AL <Integer> path
    -> if root == null return
    -> add the root.data to the path
    -> if both left and right nodes become null print the AL 'path'
    -> call the function for root.left
    -> call the function for root.right
    -> remove the last element from the AL 'path'
    -> backtracking step: path.remove(path.size() - 1)

4. Validate BST
    -> create a boolean function that takes three nodes as input: root, min and max
    -> if root == null return true
    -> if the min node is not null and its data is greater than the root.data return false
    -> else if max node is not null and its data is smaller than the root.data return false
    -> call for the left and pass root as the max 
    -> call for the right as pass root as the min
    -> lastly return (left && right)

5. Sorted array to BST 
    -> create a function that takes an array, start and ending index as inputs
    -> if the s (starting index) becomes greater than e (ending index) return null
    -> calculate min i.e. (s+e)/2
    -> create a node using arr[mid] 
    -> call for root.left = create(arr, s, mid-1)
    -> call for root.right = create(arr, mid+1, e)
    -> lastly return the root node

6. Larges BST ***
    -> create a global varialble => int maxBst = 0
    -> create a Info class that stores isBst(boolean), size, min and max of a BST
    -> create a Info type function that take root node as the input
    -> if root == null return new Info with:
	isBst = true, size = 0, min = +infinity and max = -infinity
    -> call for left and store in Info left variable
    -> call for right and store in Info right variable
    -> now size = left.size + right.size + 1
    -> min = min of root.data and min of (left.min and right.min)
    -> max = max of root.data and max of (left.max and right.max)
    -> if root.data is less than left.max || root.data is greater than right.min 
	return new Info (false, size, min, max)
    -> if isBst for both left and right is true update maxBst = Math.max(maxBst, size) 
         	return new Info (true, size, min, max)
    -> lastly return new Info (false, size, min, max)

7. Merge 2 BST:
    -> AL <Integer> inorder
    -> add values in AL = inorder from both BSTs
    -> sort (inorder)
    -> inorder (sorted array) to BST



Heap (Priority Queues):

-> PriorityQueue <Integer> pq = new PriorityQueue<>( Comparator.reverseOrder() );
    -> to sort the priority queue in descending order.

-> class Name implements Comparable<Name> 
    @override
    public compareTo(Name n)
              return ( this.rank - n.rank )   (ascending order)
	    return ( n.rank - this.rank )   (descending order)

-> children <= parent (max heap)
-> children >= parent (min heap)

-> parent = (index-1)/2
-> left = 2*index + 1		(0 based indexing)
-> right = 2*index + 2

-> CBT(complete binary tree):
    It is a tree which has all the levels completely filled
    except the last level, node are fill from left to right.
         
1. Sliding Window:
    -> create a class Window that takes value and index (constructor)
    -> sort the elements in descending order based on value in the class p.val - this.val
    -> in the main functino create a PriorityQueue i.e. 'pq' of Window type
    -> add first k elements in the pq and create an array int[] res = new int[n-k+1]
    -> res[0] = pq.peek().val
    -> for loop from i = k to arr.length
    -> if pq.size() > 0 && the index of the element in pq is greater than (i-k) then pq.remove()
        ( while(pq.size() > 0 && pq.peek().index <= (i-k)) pq.remove() )
    -> pq.add(new Window(arr[i], i))
    -> res[i-k+1] = pq.peek().value



Hashing:

-> HashMap <key(type), value(type)> m = new HashMap<>()    (no defined order of element)
-> LinkedHashMap <K,V> m = new LinkedHashMap<>()    (output elements in the same order added to the map)
-> TreeMap <K,V> m = new TreeMap<>()    (stors and output element in sorted order, sorting based on keys)

1. Majority Element
    -> let number be the key and occurence the value
    -> if m.contains(number) increase occurence
    -> output the max occured m.get(key) > max (update max)

2. Anagram
    -> create a boolean function that take two strings a & b as inputs
    -> create a HashMap <Character, Integer(occurence)> m = new HashMap<>()
    -> add all the elements of string a into the map (increase the occurence of already present)
       ( m.put(a.charAt(i), m.getOrDefault(a.charAt(i), 0)+1) )
    -> for loop traversing the string b
    -> if m.get(b.charAt(i)) != null then check 
	1. if occurence == 1 then remove(b.charAt(i))
  	2. else decrease the occurence by 1
	( m.put(b.charAt(i), m.get(b.charAt(i)-1)) )
    -> lastly return m.isEmpty()

3. Subarray Sum 0**
    -> create a HashMap <Integer(sum), Integer(index)> m = new HashMap<>();
    -> create two variables sum = 0 and len = 0 (to store length of longest with sum = 0)
    -> for loop from 0 to array.length
    -> add the elements to sum => sum += arr[i]
    -> check if the map contains the sum
    -> else put the sum and the index i in the map
    -> if m.containsKey(sum) update length:
	len = Math.max(len, i - m.get(sum))

*Here if we get the sum again at any point in the array it means that the sum 
  we calculated has already occured before in the array and if we take the 
  sum of the elements between the current index (where we found the sum) 
  and the previous index+1 (where we found the sum 1st time) it would be 0
  i - m.get(sum) would give us the length of the current subarray with sum = 0.

4. Subarray Sum k***
	int arr[] = {10, 2, -2, -20, 10};
          int k = -10;
    -> create a HashMap <Integer(sum), Integer(count)> m = new HashMap<>()
    -> put sum = 0 and count = 1 in the map
    -> create two variable sum = 0 and cnt = 0
    -> for loop from 0 to array.length
    -> add the ith element to the sum i.e. sum += arr[i]
    -> if map contains the sum-k value then increase the cnt by the values stores in map
	( cnt += m.get(sum - k) )
    -> lastly m.put(sum, m.getOrDefault(sum, 0)+1)

-> HashSet <Integer> s = new HashSet<>() (unodered, no defined order)
	-> Iterator it = set.iterator()
  	-> while ( it.hasNext() ) sot( it.next() )	
	-> for ( dataType variableName : HashSetName )

-> LinkedHashSet <Integer> s = new HashSet<>()  (output in the same order we inputed)
-> TreeSet <Integer> s = new TreeSet<>()  (sorted in ascending order)



Tries:

* tries are prefix trees also known as re'trie'val (the name comes from here) trees which work 
on prefix of words, the are k-nary trees and are bulky, requires huge amount of space but gives us 
a nice time complexity, as the height of the tree decreases the time complexity of also decreases.
k-nary -> number of children of a node can be from 0 to k.

Creating
    -> define a Node class with an array of nodes[26] and a boolean EndOfWord (eow)
    -> create a constructor and initialize nodes[26] = null using forLoop
    -> create root node ( Node root = new Node() ) that remains empty
Inserting
    -> initialize a curr node == root node
    -> traverse the given word and store the index of the character in idx variable
    -> if the character does not exist create a node 
    -> point curr at the children that exists/is created 
    -> after exiting the for loop eow == true
Searching
same as inserting just if the index does not exist return false and at the end return eow

1. Word Break ***
    -> insert the array of words into a trie
    -> create a function wordBreak that takes the key as the input
    -> using a for loop traverse the key string
    -> search for the key.substring(0,i) in the trie
    -> call wordBreak for the left part if the key.substring(i)
    -> if both gives the ouput as true return true
    -> if the length of key becomes 0 return true (base condition)
    -> finally return false 

2. Prefix Problem *****
    -> add another property frequency(freq) to the Node class
    -> initialise it by 1 when creating a Node
    -> insert the node and if already present increase the freqency

*Note: frequency of root node should be initialized as -1 before passing to the function
    -> pass two parameters root and an empty StringBuilder (ans) to the function
    -> if root becomes null return
    -> if the freq of root becomes 1 output the answer and then return
    -> traverse all the childrens of root using a for loop
    -> if the children is not null call the function for the children and add the word to the ans
    -> if we are using stringBuilder (inside for loop):
                char c = (char)(i+'a');
                ans.append(c);
                prefix(root.children[i], ans);
                ans.deleteCharAt(ans.length()-1);

3. Longest word with all Prefixes
    -> declare an ans string outside the function (global variable)
    -> pass the root and a stringBuilder(SB) to the function
    -> travese each children using a for loop
    -> if root.children[i] is not null and eow is true append the char in SB
    -> update ans with temp value if the temp is greater than the ans string
    -> call function for the children
    -> remove the last letter from the temp in backtracking step 

4. Unique Substrings ***
(unique concept of prefix and suffix used in this question)
Trie is also known as prefix tree that stores all the unique prefix of given words. Like in array of words
arr[] = {'apple', 'app', 'apple'} the prefix 'app' has occured 3 times but the Trie would store it only once.
So we will store all the prefix of all the suffix of the given string in the Trie.
    -> using a for loop traverse the given string
    -> create substring (suffix) by removing the first letter i.e str.substring(i)
    -> insert the substring in the Trie data structure
    -> now we have to count the number of nodes present in the Trie
    -> if root becomes null return 0
    -> use for loop to traverse all the children
    -> if any children is not null add it to the count
    -> call the function for that child
    -> lastly return count + 1 (1-> the root node)



Graphs:
*Network of nodes.

Properties:
1. Vertex (also know as the node witch stores the value)
2. Edge (path between two nodes/vertices)
3. Weight (it is the value of the edge, can be -ve or +ve)

There are three type of edges:
1. Uni-directed (can reach a node but cannot come back to the previous node through same path)
2. Bi-directed (can travel both sides forwrd as well as backward)
3. Undirected (no direction give can travel in any directions if path exists)


1. BFS (breadth first search)

*we start from the source node and visit all the neighbours/children of the current node we are on
and then move to the next node and repeat the same, we use a boolean vis[] array to keep check of 
the nodes we have already visited.
    -> it is an iterative function
    -> create a queue 'q' and add the source node in the queue (i.e 0)
    -> create a boolean vis[] array if size equal to the graph.length;
    -> traverse the queue using while loop until it gets empty
    -> curr = q.remove()
    -> now print curr and mark current as visited
    -> now using a for loop travers all the nodes connected to the curr node
    -> 0 to graph[curr].size() 
    -> Edge e = graph[curr].get(i)
    -> add the destination node (i.e e.dest) into the queue


2. DFS (depth first search)

*we start from the given source node and go to the 1st neighbour until we reach the last node.
Note: a graph could have move than one dfs traversals.
    -> it is a recursive function
    -> pass the graph, current node (curr) and the vis[] array to the function
    -> mark the curr node visited after printing the curr node
    -> using a for loop traverse graph[curr]
    -> Edge e = graph[curr].get(i)
    -> if the e.dest is not visited call the function for e.dest


Q 1. Has Path*
    -> pass graph, source, destination and vis[] array to the function
    -> if(source == destination) return true
    -> mark vis[source] == true
    -> traverse graph[curr] using for loop
    -> Edge e = graph[curr].get(i)
    -> check 2 conditions (&&):
	1. !vis[e.dest]
 	2. function(graph, source == e.dest, destination, vis)
    -> if both are true return true
    -> lastly return false        


3. Connected Components

They are set of vertices that are connected to each other through an edge and we can reach every other node from 
each node inside one connected component, a BST is also a graph. To findconnected components we use BFS and DFS in 
two parts. 1st part is the loop to traverse all the nodes in the graph and the second function is the helper/util function.
	
	-> pass the AL <Edge>[] graph to the bfs function
 	-> create a boolean[] vis array of size graph.length
          -> for loop 0 to graph.length
	-> *check if not visited
	-> run the bfsUtil function in it passing the graph and vis[] array in the function
	-> run the dfsUtil function in it passing the graph, i (curr node) and vis[] array 
	

 	bsfUtil
	-> create a queue of integer type
	-> add 0 as initial element to the queue
	-> traverse the queue using while loop, while !q.isEmpty()
 	-> curr = q.remove()
 	-> if the not visited mark visited and print data 
	-> for loop 0 to graph[curr].size() traversing all the neighbours of curr node
	-> Edge e = graph[curr].get(i)
	-> add e.dest to the queue q.add(e.dest)

	dfsUtil
	-> print the curr node
	-> mark it as visited
	-> travers all its neighbours 0 to graph[curr].size()
 	-> Edge e = graph[curr].get(i)
	-> if not visited call the function for e.dest


4. Cycle Detection (undirected graph)
(45min+)

Approach (dfs used):
If we are on a node and all the neighbours of that nodes already exists it means that there exists another path
to reach those nodes, in this case cycle exists. There are three cases for a nodes:

case 1:
	vis[neighbour] -> true & parent -> false
	In this case return true as the cycle exists because one of the neighbour of the current node is
	already visited and it is not the parent of the current node so there exists another path to reach
	that node which means cycle exists in the graph.

case 2:
	vis[neighbour] -> true & parent -> true
	In this case the neighbour of the current node is visited and is also the parent of the current node 
	so in this case we continue as we cannot say anything if the cycle exists or not.

case 3:
	vis[neighbour] -> false
	In this case we normally use dfs to traverse as the neighbour is not visited.

*Note: we will use the same method used in connected componets to traverse the graph. 
    -> create a detect (boolean) function that takes AL <Edge>[] graph as the input
    -> create a boolean array and traverse all the nodes using for loop
    -> if the node is not visited call the detectUtil funtion
    -> pass the graph, vis array, current node and the parent(initially -1) to the 'util' function
    -> inside 'util' funtion make the curr node visited == true
    -> run a for loop from 0 to graph[curr].size()
    -> Edge e = graph[curr].get(i)
    -> if e.dest is not visited run the 'util' function for e.dest as curr node and curr as its parent
    -> (inside previous if) if the util function for e.dest return true then return true
    -> (outside the 1st if) else if case e.dest is visited && e.dest != parent of curr node return true
    (e.dest != par means that the neighbour is not the parent of our current node)
    -> lastly return false in both the functions


5. Bipartite Graph
(1hr +)

*Defination: It is a graph whose vertices can be divided into two independent sets U and V such that every 
edge(u, v) either connects a vertex from U to V or a vertex from V to U. In other words from every edge(u, v)
either u belongs to U and v belongs to V or u belongs to V and v belongs to U. We can also say that there is no
edge that connects the vertex of same set.

Approach (bfs used):
We are going to use colors (two different) to divide the graph into two parts. We will be using a color array.
-1 -> no color
0 -> yellow
1 -> blue

case 1:
	color[neighbour] = same
	return false

case 2:
	color[neighbour] = different
	continue

case 3:
	color[neighbour] = no color
	give it a different color

    -> create bipartite function and pass AL <Edge>[] graph to the function
    -> create color array of size graph.length
    -> initialize all the values -1 in the col array
    -> create a queue, integer type
    -> traverse the graph using the for loop
    -> check if col[i] == -1 (below everything inside this if statement)
    -> if true then make col[i] = 0 and add i into the queue
    -> now run a while loop unit queue is not empty
    -> int curr = q.remove()
    -> now for loop from 0 to graph[curr].size()
    -> Edge e = graph[curr].get(i)
    -> now check if col[e.dest] == -1
    -> if true create a next color variable(nxtCol)
    -> initailize it with the opposite color(i.e of the curr node) 
    -> nxtCol = (col[curr] == 0) ? 1: 0
    -> put the color of the neighbour node as nxtCol (col[e.dest] == nxtCol)
    -> add e.dest to the queue
    -> in else if condition check if the neighbour and the curr node has the same color
    -> else if(col[e.dest] == col[curr]) is true, they have same color so return false
    (else if condition corresponding to if(col[e.dest] == -1) )


6. Cycle Detection (directed graph)

Approach (modified dfs used):
We will be using a modified DFS approach with an explicit stack.
implicit -> the stack which is formed while execution a recursive function
explicit -> the stack that we make other than the recursive stack

We will use a boolean array (stack) to store the visited neighbours, if the neighbours are present in the stack it 
would return true, else if there are no neighbours it would return false.

    -> create a detect function which takes AL <Edge>[] graph as the input
    -> create a boolean vis[] and stack[] array of size = graph.length
    -> traverse the graph using for loop from 0 to graph.length
    -> if any index is not visited run 'util' funtion for it
    -> 'util' function take the graph, i-> curr node, vis[] and stack[] as input
    -> in 'util' make vis[curr] & stack[curr] == true
    -> for loop from 0 to graph[curr].size()
    -> Edge e = graph[curr].get(i)
    -> if e.dest exists in the stack return true to main function
    -> if e.dest is not visited && 'util' for e.dest give true, return true to main function
    -> when the for loop ends put stack[curr] = false (popping out of the stack)
    -> lastly return false in both the functions


7. Topological Sort

Directed
Acyclic 		Topological sort is used on these graphs (DAGs)
Graphs

It is a linear order of vertices such that every directed edge u -> v, the vertex u comes before v in order, we 
use dfs to traverse the graph and stack to store the nodes (which comes 1st and which comes last).

    -> create a topSort function which takes AL <Edge>[] graph as input
    -> create a visited array and a stack of integer type
    -> use a for loop to traverse all the nodes of the graph, 0 to graph.length
    -> if an index is not visited run the 'util' function for the index
    -> 'util' function takes graph, i-> curr node, vis[] and stack s as inputs
    -> in 'util' function mark curr nodes as visited
    -> for loop form 0 to graph[curr].size;
    -> Edge e = graph[curr].get(i)
    -> if e.dest is not visited run the 'util' function for e.dest as curr node
    -> after the loop ends push curr in the stack 
    -> output the stack values in the topSort function after the for loop


8. Kahn's Algorithm
(1hr+)

(topological sort using BFS approach)
in-degree -> number of edges coming into the node
out-degree -> number of edges going out of the node

Approach:
We will calculate the in and out degree of each node. 
** In a DAG there always exists a node which has in-degree of 0 and a node that has out-degree of 0.

    -> create a function inDegree to calculate the indegree of each node
    -> the inDegree function takes the graph and an array indeg[graph.length] as inputs
    -> using a for loop travers the nodes of the  graph 0 to graph.length
    -> using a nested loop traverse the arrayList associated with each node graph[i].size()
    -> Edge e = graph[i].get(j)
    -> increase the indegree of e.dest by one indeg[e.dest]++
    (as there exists one path to reach the node so number of incoming edges, indegree will be increased)
    -> now for the topSort (main function), take graph as the input
    -> create a new array indeg[], pass the array and the graph to the inDegree function
    -> now the indeg[] array stores the indegree of each node
    -> create a queue of integer type and add all the nodes with indegree == 0 into the queue
    -> using a while loop traverse the queue
    -> int curr = q.remove(), print curr
    -> for loop 0 to graph[curr].size()
    -> Edge e = graph[curr].get(i)
    -> now decrease the indegree of e.dest = indeg[e.dest]--
    -> if indeg[e.dest] becomes 0 add it to the queue


Q 2. All Path 
(Easy Question)
    -> create a function paths that takes the graph, src, dest and a string path as input
    -> base: if the src == dest print path+src and return
    -> using a for loop travere the neighbours of src node i.e from 0 to graph[src].size()
    -> Edge e = graph[src].get(i)
    -> call the path function for e.dest as the source and add src to path
    -> paths(graph, e.dest, dest, path+src)


9. Dijkastra's Algorithm
(1hr 30min+)

(gaand faaad code h iska)
*shortest path from a given source to all the nodes in the graph (weighted & directed graph).
It is a greedy algorithm in graphs.

Logic behind Dijkastra's Algo:
Taking 3 nodes 0, 1 and 2:
	0 to 1 edge wt = 2
 	1 to 2 edge wt = 4
	there is no direct path from 0 to 2

0 is the src node:
** If there exist a direct path from the src node to another node then the distance from the src node to the dest
node becomes equal to the weight of the edge. If there is no direct path from src to the dest node then the distance
between the nodes is said to be infinity so
0 to 1 distance = 2
0 to 2 distance  = infinity as there exist no direct path

0 is the src node, 1 is 'u' and 2 is 'v':
dist[u] = 2
wt(u,v) = 4  (weight of the edge between u and v)
dist[v] = infinity

**main logic behind the code:
if dist[u] + wt(u,v) is less than dist[v] then
dist[v] = dist[u] + wt(u,v)

*initially take the distance from src to all other nodes as infinity
    -> add wt property to the edge class
    -> create a pair class that implements comparable interface
    -> it stores the node and the path, both integers
    -> compareTo = return this.path - p.path
    -> create dijkastra function that takes the graph and int src as the input
    -> create a dis[graph.length] array and initialize all the values as infinity except the src node
    -> create a boolean vis[graph.length] array and a PriorityQueue <Pair> pq = new PriorityQueue
    -> add (new Pair(0,0) ) to the pq
    -> traverse the pq using while loop until !pq.isEmpty()
    -> Pair curr = q.remove()
    -> if curr.node is not visited (all below inside this if statement)
    -> first mark the node as visited
    -> for loop form 0 to graph[curr.node].size()
    -> Edge e = graph[curr.node].get(i)
    -> int u = e.src
    -> int v = e.dest
    -> int w = e.wt
    -> if the sum of dis[u] and w is less than dis[v]
    -> update dis[v] = dis[u] + w
    -> after the while loop output all the values of the dis[] array


10. Bellman Frod's Algorithm

*shortest path from source to all vertices, supports negative vertices that Dijkastra'a Algo does not support.
Note: does not work for negative weighted cycle

    -> create a function BF that takes graph as the input
    -> create a dis[graph.length] array 
    -> initialise all the index as infinity except the source node
    -> 1st for loop 0 to V-1  (V = graph.length)
    -> 2nd for loop 0 to graph.length
    -> 3rd for loop 0 to graph[j].size()
    -> Edge e = graph[j].get(k)
    -> int u = e.src
    -> int v = e.dest
    -> int w = e.wt
    -> if dis[u] != infinity and dis[u] + w is less than dis[v]
    -> update dis[v] with dis[u] + w
    -> after all 3 for loops output the values stored in dis[] array


11. Prim's Algorithm

*MST (minimum spanning tree)
A MST is a subset of edges of a connected edge weighted graph that connects all the vertices
together without any cycle and with minimum possible total edge weight.
** sum of weight = minimum possible

    -> create a Pairs class that implements the Compareable interface
    -> it stores the cost and the vertex and sorts based on cost i.e this.cost - p.cost
    -> the main prims function takes the graph as the input
    -> create a boolean[] vis array of size graph.length
    -> create a PriorityQueue <Pair> q = new PriorityQueue<>()
    -> add new Pair(0, 0) to q and create a new variable int cost = 0
    -> traverse q using while loop
    -> Pair curr = q.remove()
    -> if curr.v is not visited (all below inside this if statement)
    -> 1st mark curr.v as visited and add curr.c to the cost (variable we created)
    -> for loop 0 to graph[curr.v].size()
    -> Edge e = graph[curr.v].get(i)
    -> q.add(new Pair(e.dest, e.wt))
    -> after while loop is finished return cost


Q 3. Cheapest Flight with K stops
    -> take n = flights.length where flights is a 2D array
    -> create a graph of size == n and push the graph and flights array into create graph function
    -> create a distance array dis[] = new int[n]
    -> except the src node put all the values in dis[] array == +infinity
    -> create a Queue using Info class 
    -> Info class contains vertex, cost and the no. of stops
    -> add vertex = src, cost = 0 and stops = 0 in the queue
    -> run a while loop until queue is not empty
    -> Info curr = q.remove()
    -> if curr.stops becomes greater than k break the loop
    -> for loop from 0 to graph[curr.vertex].size()
    -> Edge e = graph[curr.vertex].get(i)
    -> v = e.dest and w = e.wt
    -> if curr.cost + w is less than dis[v] and curr.stops <= k then dis[v] = curr.cost + w
    -> q.add( new Info(e.dest, dis[v], curr.stops+1) )
    -> after while loop check if dis[dest] is +infinity, if true return -1
    -> else return dis[dest]


Q 4. Connecting Cities
    -> create a edge class that will contain the destination and the cost
    -> @Override and return this.cost - e.cost (ascending/increasing order)
    -> create a connectCities function that takes a 2d array (int[][] cities) as input
    -> create a variable finalCost = 0 to store the cost and return it at last
    -> create a boolean[] vis array with length == cities.length
    -> create a PQ with Edge type and add new Edge(0, 0) initially
    -> run a while loop until PQ is not empty
    -> Edge curr = pq.remove()
    -> if curr.dest is not visited 
    -> mark vis[curr.dest] == true
    -> update finalCost i.e. += curr.cost
    -> for loop from 0 to cities[curr.dest].length
    -> if cities[curr.dest][i] is not equal to 0
    -> add new Edge( i, cities[curr.dest][i] ) to the pq
    -> after the while loop return finalCost


12. Disjoint Set
(union and find)

Logically stores elements in form of groups/sets. We use find function to find to which set does the element
belongs to and union function to join 2 sets and make them into a single group.

Implementation:
Parent . union by rank
We use 2 arrays par[] and rank[] where initially the element itself is the parent and the rank of all the elements is 0.
find -> returns the leader/parent of the groups/set
union -> joins the groups/sets
*union is always done between the leaders/parents of the two groups/sets.     

    -> create a global variable int n = 7 (or any size)
    -> create two global arrays par[n] and rank[n]
    -> create void function init() to initialize the parents of each node (par[i] == i)
    -> create a function find that takes an integer as the input
    -> if x == par[x] return x
    -> else call the function for par[x]
    -> create a union functin that take two integers as the inputs
    -> create a variable int parA to store the parent of integer a
    -> create a variable int parB to store the parent of integer b
    -> parA = find(a) and parB = find(b)
    -> if rank of both parents is same make any one of them as the parent and increase its rank
    -> else if rank of parA is greater make it the parent of parB and increase its rank
    -> last case (else) make parB the parent of parA and increase its rank

Optimisation (path compression):
int find(int x) {
	if(x == par[x]) return x;
	return par[x] = find(x);
}
    -> par[x] = find(x) is the optimisation.
    -> we will store the parent for the current node that find function will return
    -> after this we don't have to call the find function for all the element
    -> it would make the supreme leader the parent of all the element
    -> eg:
	if 3 was the parent of 6 and 6 is the parent of 4 but the parent of 3 is 1, so we would make 1 the parent of 6 as well
	as the parent of 4 so the path gets compressed and the 1 becomes the parent of 3, 4 and 6 as the find function previously
	aslo would have returned 1 if we called it for any element i.e. 3, 4 or 6.


13. Kruskal's Algorithm
Algorithm used to find out MST, Greedy Approach.
1. Stores Edges
2. Take minimum cost edges (does not form cycle)
V nodes -> V-1 edges are needed

    -> create Edge class the implements Comparable interface
    -> it contains the src, dest & wt and return this.wt - e.wt
    -> create a function kruskal that takes int V as input
    -> AL<Edge> edges = new AL<>() and pass it into createGraph function
    -> call the init() function to initialize the parents of nodes
    -> use Collections.sort(edges) to sort the edges in ascending order
    -> create integers mst and cnt and initialise them with 0
    -> for loop (int i=0; cnt < V-1; i++)
    -> Edge e = edges.get(i)
    -> parA = find(e.src)
    -> parB = find(e.dest)
    -> if parA and parB are not equal union(e.src, e.dest) 
    -> add e.wt to mst and increase cnt by 1 (cnt++)
    -> lasty return mst



DP (Dynamic Programming):

(**! interview)
Dynamic Programming is a technique in computer programming that helps to efficiently solve a class of problems
that have overlapping subproblems and optimal structure properties.

Ways of DP:
1. Memoization (top down approach)
    -> normal recursion
    -> subproblem (store and reuse the returned value)

2. Tabulation (bottom up approach)
     -> no recursion, we use iterations 
 *more efficient and no overflow condition (base case)
   uses table for iterations 

eg:- Fibonacci Series
0 1 1 2 3 5 8 13 21 34 55 89 .....................

for n = 6 ans = 8
in this case fib[2] is called 5 times, same for fib(3) and fib(4)

DP approach:
1. Memoization
    -> we will use an array to store the fib[n] (int[] f = new int[n+1])
    -> size is n+1 as we will store number from 0 to n (both included)
    -> return f[n] = fib(n-1, f) + fib(n-2, f)

2. Tabulation 
    -> create array int[] dp = new int[n+1] 
    -> as the base case in recursion is for 0 and so initialize dp[0] = 0 and dp[1] = 1
    -> now a for loop from 1 to n+1
    -> inside for loop => dp[i] = dp[i-1] + dp[i-2]
    -> alternate if dp[0] = 0 is only initialized not dp[0]
    -> dp[i] = dp[i-1] + (i == 1 ? 1 : dp[i-2])

7 Important Questions:
1. Fibonacci
2. 0 - 1 Knapsack
3. Unbounded Knapsack
4. LCS (longest common subsequence)
5. Kadan's Algorithm (arrays)
6. Catalan Number
7. DP on Grid (2d arrays)


Q1. Climbing Stairs (Fibonacci)
Count the number of ways to reach the nth stair. The person can climb either 1 or 2 stairs at a time.

1. Memoization
    -> create a function 'fib' that takes an integer n and an array int[] f as inputs
    -> if n == 0 or n == 1 return n (base case)
    -> if n is present in the array f[] return f[n]
    -> if( f[n] != 0) return f[n]
    -> else return fib(n-1, f) + fib(n-2, f) and store it in f[n]

2. Tabulation 
    -> create a function 'fib' that takes and integer n as input
    -> create an array = int[] dp = new int[n+1]
    -> initialise dp[0] = 0 (base case)
    -> for loop from 1 to n+1
    -> dp[i] = dp[i-1] + (i == 1 ? 1 : dp[i-2])
    -> lastly return dp[n]

Q2. 0 - 1 Knapsack
0 -> item has not been taken
1 -> item has already been taken

item(value, weight) => tow contitions
 	1. exlude (0)
 	2. include (1)
		-> cost after including the item		
		-> cost after exluding the item
		(max of both is returned)

1. Memoization
    -> create an array = int[][] dp = new int[items+1][maxWeight+1]
    -> initialise all the values in the dp[i][j] = -1
    -> create a function KS that takes val[], wt[], W, n and dp[][] as the input
    -> if n == 0 || W == 0 return 0
    -> if dp[n][W] != -1 return dp[n][W]
    -> if the wt of nth item is less than or equal to W (wt[n-1] <= W)
    (this is the include case (1))
    -> exclude case: dp[n][W] = KS(val, wt, W, n-1, dp)
    -> include case: dp[n][W] = val[n-1] + KS(val, wt, W - wt[n-1], dp)
    -> return the max of the include and exclude case
    -> lastly return dp[n][W] = KS(val, wt, W, n-1, dp)
    (this is the exclude case (0))

2. Tabulation
    -> create a function KS that take val[], wt[] and W as inputs
    -> create an arry = int[][] dp = new int[val.lenght+1][W+1]
    -> for loop = 1 to val.length + 1(i) and 1 to W+1(j)
    -> int v = val[i-1] 
    -> int w = wt[i-1]
    -> if w <= j 
    -> int exclude = dp[i-1][j]
    -> int include = v + dp[i-1][j-w]
    -> dp[i][j] = Math.max(include, exlude)
    -> else dp[i][j] = dp[i-1][j]
    -> lastly return dp[n][W]


Q3. Target Sum
** not understood how the code works
num[] = {4, 2, 7, 1, 3}
targetSum = 10
ans = true

total subsets = 2pow(n)
as every element has 2 choices to be included or excluded

1. choice of elements
2. limit on max allowed capacity		   (similar to knapsack)
3. value = weight

*size of array and targetSum are two variables
    -> create a boolean function targetSum that takes int[] arr and targetSum as inputs
    -> create an array int[][] dp = new int[n+1][targetSum+1]
    -> for all dp[i][0] mark true
    -> outer loop 0 to n+1 and inner loop 0 to targetSum+1
    -> int v = arr[i-1]
    -> if (v<=j && dp[i-1][j-v] == true) dp[i][j] = true
    -> else if (dp[i-1][j] == true) dp[i][j] = true
    -> lastly return dp[n][targetSum]


Q4. Unbounded Knapsack
val[] = 15, 14, 10, 45, 30
wt[] = 2, 5, 1, 3, 4				ans = 100
W = 7
*here the quantity of each item is infinite

*(value & weight) and W are two variable
    -> create an int function uKnapsack that take int[] val, int[] wt and W as inputs
    -> create an array int[][] dp = new int[val.length][W+1] initally all values are 0
    -> outer = 1 to val.length+1 and inner = 1 to W+1
    -> int v = val[i-1]
    -> int w = wt[i-1]
    -> if the weight(w) is less than or equal to the capacity(j)
    -> include the item => int in = v + dp[i][j-w]
    -> exclude the item => int ex = dp[i-1][j]
    -> dp[i][j] = Math.max(in, ex)
    -> else exclude => dp[i][j] = dp[i-1][j]
    -> lastly return dp[val.length][W]


Q5. Coin Change
(unbounded knapsack variation and an interview question)

coins[] = {2, 3, 5, 6}
sum = 10
ans = total number of ways i.e. 10

*coins(idx) and sum are the two variables
    -> create a funtion coinChange the take the coins[] array and the sum as input
    -> create an array int[][] dp = new int[coins.length+1][sum+1] initially all values are 0
    -> initiallise all the value in the 1st column as 1
    -> outer = 1 to coins.length+1 and inner = 1 to sum+1
    -> int c = coins[i-1]
    -> if value of coin(c) is less than or equal to sum(j)
    -> include the coin => int in = dp[i][j-c]
    -> exclude the coin => int ex = dp[i-1][j]
    -> dp[i][j] = in + ex (as we want the total number of ways)
    -> else exclude => dp[i][j] = dp[i-1][j]
    -> lastly return dp[coins.length][sum]


Q6. Rod Cutting
len[] = {1, 2, 3, 4, 5, 6, 7, 8}
price[] = {1, 5, 8, 9, 10 , 17, 17, 20}		ans = 22
rodLength = 8

*(length & price) and rodLength are the two variables
    -> create a function rodCutting that takes int[] len, int[] price and int R(rodLength) as inputs
    -> create an array int[][] dp = new int[len.length+1][R+1] initially all values are 0
    -> outer = 1 to len.length+1 and inner = 1 to R+1
    -> int l = len[i-1]
    -> int p = price[i-1]
    -> if the length(l) is less than or equal to the rodLength(j)
    -> include => int in = p + dp[i][j-l]
    -> exclude => int ex = dp[i-1][j]
    -> dp[i][j] = Math.max(in, ex)
    -> else dp[i][j] = dp[i-1][j]
    -> lastly return dp[len.length][R]

Q7. Longest Common Subsequence (LCS)
A subsequence of a string is a new string generated from the original string with same characters (can be none),
deleted without changing the *relative order of remaining characters.

a = "abcde" & b = "ace"
ans = 3 ("ace")

a = "abcdge" & b = "abedg"
ans = 4 ("abdg")

1. Recursion
    -> create a function LCS that take the two string(a & b) and the length of the strings(n & m) as input
    -> if n || m, any one of them becomes 0 return 0
    -> if a.charAt(n-1) matches b.charAt(m-1) return LCS(a, b, n-1, m-1) + 1
    -> else decrease the length of one string, pass it in the function and store it in int ans1
    -> decrease the length of other string, pass it in the function and store it in int ans2
    -> return the max of ans1 and ans2 inside the else paranthesis

2. Memoization
    -> create function LCS same as in recursion and a int[][] dp = new int[n+1][m+1] as inputs
    -> if n || m, any one of them becomes 0 return 0
    -> if dp[n][m] != -1 return dp[n][m]
    -> if a.charAt(n-1) matches b.charAt(m-1) return dp[n][m] = LCS(a, b, n-1, m-1) + 1
    -> else decrease the length of one string, pass it to the function and store it in ans1
    -> decrease the length of other string, pass it to the function ans store it in ans 2
    -> return the max of ans1 and ans2 inside the else paranthesis and store the value in dp[n][m]

3. Tabulation
    -> create a function LCS that take two strings a & b as inputs
    -> create an array int[][] dp = new int[a.length()+1][b.length()+1] initially all values are 0
    -> outer = 1 to a.length+1 and inner = 1 to b.length+1
    -> if a.charAt(i-1) == b.charAt(j-1) then dp[i][j] = dp[i-1][j-1] + 1
    -> else decrease the length of one string and store in int ans1 = dp[i-1][j]
    -> decrease the length of other string and store in int ans2 = dp[i][j-1]
    -> dp[i][j] = Math.max(ans1, ans2)
    -> lastly return dp[n][m]


Q8. Longest Common Substring
*if we find the LCS from the starting or the end the answer remains the same

a = "ABCDE" & b = "ABGCE"
ans = 2 ("AB")

    -> create a function that takes two strings a & b as inputs
    -> create an array int[][] dp = new int[a.length()+1][b.length()+1]
    -> outer = 1 to a.length+1 and inner = 1 to b.length+1
    -> create a variable int ans = 0
    -> if a.charAt(i-1) == b.charAt(j-1) then dp[i][j]  = dp[i-1][j-1]+1 
    -> ans = Math.max(ans, dp[i][j])
    -> else dp[i][j] = 0
    -> lastly return dp[n][m]


Q9. Longest Increasing Subsequence

arr[] = {50, 3, 10, 7, 40, 80}
ans = 4 ( {3, 10, 40, 80} or {3, 7, 40, 80} )

    -> create a function LIS that take an array int[] arr1 as input
    -> create a HashSet of Integer type and add all the elements from array to it
        (this is to remove all the duplicate values from the array)
    -> create a new array int arr2 of HashSet.size() and add all the elements from HashSet into it
    -> sort arr2
    -> lastly return LCS(arr1, arr2)


Q10. Edit Distance

word1 = "intention" & word2 = "execution"
1. intention - inention (remove 't')
2. inenetion - enention (replace 'i' with 'e')
3. enention - exention (replace 'n' with ' x')
4. exention - exection (replce 'n' with 'c')
5. exection - execution (insert 'u') 

ans = 5

add -> a(n) b(m-1) + 1
delete -> a(n-1) b(m) + 1
insert -> a(n-1) b(m-1) + 1
*find the minimum of all three

    -> create a function that takes two strings a & b as input
    -> create an array int[][] dp = new int[n+1][m+1]
    -> if i == 0 dp[i][j] = j and j == 0 dp[i][j] = 
(as if one string is empty the number of operations will be equal to the length of other string)
    -> outer 1 to n+1 and inner 1 to m+1
    -> if a.charAt(i-1) == b.charAt(j-1) dp[i][j] = dp[i-1][j-1] + 1
    -> else perform 3 operation i.e. add, delete & replace and take the minimum
	add -> dp[i][j] = dp[i][j-1] + 1
  	del -> dp[i][j] = dp[i-1][j] + 1
  	rep -> dp[i][j] = dp[i-1][j-1] + 1
    -> dp[i][j] = min(add, del, rep)
    -> lastly return dp[n][m]


Q11. String Conversion

a = "ABCDEF" & b = "ACEG"
convert the string a to string b

lcs = "ACE"
-> only 3 letters are common in both the strings

deletion = a.length() - lcs	(as these no. of letters are not present in the second string)
insetion = b.length() - lcs	(as these no. of letters are extra present in the second string)
(lcs - longest common subsequence)












 








